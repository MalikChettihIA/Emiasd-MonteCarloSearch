# Classe Move - Jeu Breakthrough

## Vue d'ensemble

La classe `Move` représente un coup dans le jeu Breakthrough. Elle encapsule toutes les informations nécessaires pour décrire un mouvement de pion : joueur, position de départ et position d'arrivée. Elle fournit également des méthodes pour valider les coups et les encoder numériquement.

## Structure de la classe

### Constructeur `__init__()`

```python
def __init__(self, color, x1, y1, x2, y2):
    self.color = color  # Couleur du joueur (White=1 ou Black=2)
    self.x1 = x1        # Position x de départ
    self.y1 = y1        # Position y de départ  
    self.x2 = x2        # Position x d'arrivée
    self.y2 = y2        # Position y d'arrivée
```

**Paramètres** :
- `color` : `White` (1) ou `Black` (2)
- `(x1, y1)` : Coordonnées de la case source
- `(x2, y2)` : Coordonnées de la case destination

**Système de coordonnées** :
- `x` : Lignes (0 à 4, de bas en haut pour les Blancs)
- `y` : Colonnes (0 à 4, de gauche à droite)

## Méthode `valid(board)`

Valide si le coup est légal selon les règles de Breakthrough.

### Vérifications communes

```python
# Vérification des limites du plateau
if self.x2 >= Dx or self.y2 >= Dy or self.x2 < 0 or self.y2 < 0:
    return False
```
Empêche les mouvements hors du plateau 5×5.

### Règles pour les Blancs (`color == White`)

```python
if self.color == White:
    # Les blancs ne peuvent avancer que d'une ligne vers le haut
    if self.x2 != self.x1 + 1:
        return False
        
    if board.board[self.x2][self.y2] == Black:
        # Capture : seulement en diagonale
        if self.y2 == self.y1 + 1 or self.y2 == self.y1 - 1:
            return True
        return False
        
    elif board.board[self.x2][self.y2] == Empty:
        # Mouvement vers case vide : vertical ou diagonal
        if self.y2 == self.y1 + 1 or self.y2 == self.y1 - 1 or self.y2 == self.y1:
            return True
        return False
```

**Mouvements valides pour les Blancs** :
- **Avancer** : Une case vers le haut (x+1), même colonne (y identique)
- **Avancer en diagonale** : Une case vers le haut (x+1), colonne adjacente (y±1)
- **Capturer** : Uniquement en diagonale vers case occupée par un Noir

### Règles pour les Noirs (`color == Black`)

```python
elif self.color == Black:
    # Les noirs ne peuvent avancer que d'une ligne vers le bas  
    if self.x2 != self.x1 - 1:
        return False
        
    if board.board[self.x2][self.y2] == White:
        # Capture : seulement en diagonale
        if self.y2 == self.y1 + 1 or self.y2 == self.y1 - 1:
            return True
        return False
        
    elif board.board[self.x2][self.y2] == Empty:
        # Mouvement vers case vide : vertical ou diagonal
        if self.y2 == self.y1 + 1 or self.y2 == self.y1 - 1 or self.y2 == self.y1:
            return True
        return False
```

**Mouvements valides pour les Noirs** :
- **Avancer** : Une case vers le bas (x-1), même colonne (y identique)
- **Avancer en diagonale** : Une case vers le bas (x-1), colonne adjacente (y±1)
- **Capturer** : Uniquement en diagonale vers case occupée par un Blanc

## Méthode `code(board)`

Encode le coup sous forme d'entier unique pour les algorithmes AMAF (All-Moves-As-First).

### Détection de la direction

```python
direction = 0
if self.y2 > self.y1:      # Mouvement vers la droite
    if board.board[self.x2][self.y2] == Empty:
        direction = 1       # Avancée diagonale droite
    else: 
        direction = 2       # Capture diagonale droite
        
if self.y2 < self.y1:      # Mouvement vers la gauche
    if board.board[self.x2][self.y2] == Empty:
        direction = 3       # Avancée diagonale gauche
    else:
        direction = 4       # Capture diagonale gauche
        
# direction = 0 pour avancée verticale (y2 == y1)
```

**Codes de direction** :
- `0` : Avancée verticale
- `1` : Avancée diagonale droite (vers case vide)
- `2` : Capture diagonale droite
- `3` : Avancée diagonale gauche (vers case vide)
- `4` : Capture diagonale gauche

### Calcul du code final

```python
if self.color == White:
    return 5 * (Dy * self.x1 + self.y1) + direction
else:
    return 5 * Dx * Dy + 5 * (Dy * self.x1 + self.y1) + direction
```

**Formule de codage** :
- **Base** : `5 * (position_case)` où `position_case = Dy * x1 + y1`
- **Direction** : `+ direction` (0 à 4)
- **Séparation** : `+ 5 * Dx * Dy` pour les Noirs (évite les collisions)

### Exemple de calcul

Pour un pion blanc en (1,2) avançant vers (2,2) :
- `position_case = 5 * 1 + 2 = 7`
- `direction = 0` (avancée verticale)
- `code = 5 * 7 + 0 = 35`

Pour un pion noir en (3,1) capturant vers (2,0) :
- `position_case = 5 * 3 + 1 = 16`
- `direction = 4` (capture diagonale gauche)
- `code = 5 * 5 * 5 + 5 * 16 + 4 = 125 + 80 + 4 = 209`

## Utilisation avec AMAF

Le système de codage permet aux algorithmes AMAF de :

### Traquer les statistiques par type de coup
```python
def playoutAMAF(board, played):
    while True:
        moves = board.legalMoves()
        if board.terminal():
            return board.score()
        n = random.randint(0, len(moves) - 1)
        played.append(moves[n].code(board))  # Enregistre le code
        board.play(moves[n])
```

### Différencier les actions
- **Coups d'avancée** (`direction = 0, 1, 3`) : Stratégie progressive
- **Coups de capture** (`direction = 2, 4`) : Tactiques agressives
- **Position d'origine** : Importance stratégique des cases

### Optimiser la sélection
Les algorithmes comme RAVE utilisent ces codes pour :
- Calculer des moyennes par type de coup
- Pondérer les stratégies d'avancée vs capture
- Adapter le style de jeu selon la position

## Constantes associées

```python
MaxCodeLegalMoves = 2 * Dx * Dy * 5  # = 250
```
- **Facteur 2** : Blancs + Noirs
- **Dx * Dy** : Nombre de cases (25)
- **Facteur 5** : Nombre de directions possibles

## Applications pratiques

### Validation de coups
```python
move = Move(White, 1, 2, 2, 2)  # Blanc avance de (1,2) à (2,2)
if move.valid(board):
    board.play(move)
```

### Génération et filtrage
```python
# Dans Board.legalMoves()
for i in range(Dx):
    for j in range(Dy):
        if self.board[i][j] == self.turn:
            for k in [-1, 0, 1]:
                for l in [-1, 0, 1]:
                    m = Move(self.turn, i, j, i + k, j + l)
                    if m.valid(self):        # Utilise la validation
                        moves.append(m)
```

### Intégration AMAF
```python
def updateAMAF(t, played, res):
    for i in range(len(played)):
        if played[:i].count(played[i]) == 0:  # Premier occurrence
            t[3][played[i]] += 1              # Utilise le code comme index
            t[4][played[i]] += res
```

## Optimisations possibles

### Performance
- Cache des validations pour positions répétées
- Pré-calcul des codes pour mouvements fréquents
- Vectorisation des vérifications de limites

### Extensibilité
- Support de plateaux de tailles différentes
- Règles de jeu alternatives (variantes de Breakthrough)
- Encodage adaptatif selon la complexité du jeu

## Exemple d'utilisation complète

```python
# Création et validation d'un coup
board = Board()
move = Move(White, 1, 2, 2, 3)  # Avancée diagonale droite

print(f"Coup valide : {move.valid(board)}")
print(f"Code du coup : {move.code(board)}")

if move.valid(board):
    board.play(move)
    print("Coup joué avec succès")

# Dans une simulation AMAF
played_moves = []
while not board.terminal():
    moves = board.legalMoves()
    selected_move = random.choice(moves)
    played_moves.append(selected_move.code(board))
    board.play(selected_move)
```

## Conclusion

La classe Move fournit une abstraction complète et efficace pour représenter les coups de Breakthrough. Sa méthode de validation implémente fidèlement les règles du jeu, tandis que son système d'encodage permet une intégration optimale avec les algorithmes Monte Carlo avancés comme AMAF et RAVE. Cette conception modulaire facilite l'extension vers d'autres variants du jeu et l'optimisation des performances.