# Algorithme RAVE (Rapid Action Value Estimation)

## Vue d'ensemble

**RAVE** (Rapid Action Value Estimation) est une amélioration majeure de UCT qui combine les estimations Monte Carlo traditionnelles avec l'heuristique **AMAF** (All-Moves-As-First). Cette technique révolutionnaire a transformé les programmes de Go et autres jeux, permettant une évaluation beaucoup plus rapide et précise des coups.

## Le problème que RAVE résout

### Limitations de UCT standard
- **Convergence lente** : Chaque coup doit être testé individuellement
- **Peu d'informations partagées** entre positions similaires
- **Estimations imprécises** avec peu de simulations

### Solution RAVE
RAVE partage l'information en assumant que **la valeur d'un coup est similaire, peu importe quand il est joué dans une partie**.

## Concept fondamental : AMAF

### All-Moves-As-First Heuristic
L'idée centrale est que si un coup `A` apparaît dans une simulation (même joué plus tard), cette information peut servir à estimer la valeur de jouer `A` immédiatement.

### Exemple concret
```
Position de départ → Coup B → ... → Coup A → Victoire
```
AMAF utilise ce résultat pour améliorer l'estimation de jouer `A` directement depuis la position de départ.

## Analyse du code RAVE

### 1. Fonction `playoutAMAF()`

```python
def playoutAMAF(board, played):
    while True:
        moves = board.legalMoves()
        if len(moves) == 0 or board.terminal():
            return board.score()
        n = random.randint(0, len(moves) - 1)
        played.append(moves[n].code(board))  # Enregistre le code du coup
        board.play(moves[n])
```

**Différences avec `playout()` standard** :
- **Enregistrement** : Sauvegarde le code de chaque coup joué
- **Traçabilité** : Permet de savoir quels coups ont contribué au résultat
- **Mémoire** : La liste `played` contient tous les codes des coups de la simulation

### 2. Structure de données étendue `addAMAF()`

```python
MaxCodeLegalMoves = 2 * Dx * Dy * 5  # 250 pour Breakthrough 5x5

def addAMAF(board):
    nplayouts = [0.0 for x in range(MaxLegalMoves)]        # UCT standard
    nwins = [0.0 for x in range(MaxLegalMoves)]            # UCT standard
    nplayoutsAMAF = [0.0 for x in range(MaxCodeLegalMoves)] # AMAF playouts
    nwinsAMAF = [0.0 for x in range(MaxCodeLegalMoves)]     # AMAF wins
    Table[board.h] = [0, nplayouts, nwins, nplayoutsAMAF, nwinsAMAF]
```

**Extension de la table de transposition** :
- `Table[hash][0]` : Nombre total de visites
- `Table[hash][1]` : Playouts par coup (UCT)
- `Table[hash][2]` : Victoires par coup (UCT)  
- `Table[hash][3]` : **Playouts AMAF par code de coup**
- `Table[hash][4]` : **Victoires AMAF par code de coup**

### 3. Mise à jour AMAF `updateAMAF()`

```python
def updateAMAF(t, played, res):
    for i in range(len(played)):
        if played[:i].count(played[i]) == 0:  # Première occurrence seulement
            t[3][played[i]] += 1              # Incrémente playouts AMAF
            t[4][played[i]] += res            # Ajoute résultat AMAF
```

**Logique importante** :
- **Première occurrence** : Seule la première fois qu'un coup apparaît compte
- **Évite la double comptabilisation** : Un coup répété n'est pas recompté
- **Met à jour globalement** : Tous les coups de la simulation bénéficient du résultat

### 4. Sélection RAVE combinée

```python
def RAVE(board, played):
    if board.terminal():
        return board.score()
    
    t = look(board)
    if t != None:
        # ... sélection du meilleur coup avec combinaison UCT + AMAF
        for i in range(0, len(moves)):
            code = moves[i].code(board)
            if t[3][code] > 0:  # Si statistiques AMAF disponibles
                # Calcul du paramètre de pondération β
                beta = t[3][code] / (t[1][i] + t[3][code] + 1e-5 * t[1][i] * t[3][code])
                
                # Valeur UCT standard
                Q = t[2][i] / t[1][i] if t[1][i] > 0 else 1
                if board.turn == Black:
                    Q = 1 - Q
                
                # Valeur AMAF
                AMAF = t[4][code] / t[3][code]
                if board.turn == Black:
                    AMAF = 1 - AMAF
                
                # Combinaison pondérée
                val = (1.0 - beta) * Q + beta * AMAF
```

## Formule de pondération β

### Calcul de β
```python
beta = nAMAF / (nUCT + nAMAF + bias * nUCT * nAMAF)
```

Où :
- `nAMAF` = nombre de simulations AMAF pour ce coup
- `nUCT` = nombre de simulations UCT directes pour ce coup  
- `bias = 1e-5` = terme de régularisation (très petit)

### Comportement de β

| Situation | nUCT | nAMAF | β ≈ | Interprétation |
|-----------|------|-------|-----|----------------|
| **Début** | 0 | > 0 | 1.0 | Pure AMAF |
| **Équilibré** | 50 | 50 | 0.5 | Moyenne UCT/AMAF |
| **Mature** | > 100 | faible | 0.1 | Principalement UCT |

### Évolution dynamique
```
β commence à 1 (AMAF dominant) → décroît vers 0 (UCT dominant)
```

## Combinaison UCT + AMAF

### Formule finale
```
Valeur_finale = (1 - β) × UCT_value + β × AMAF_value
```

### Avantages de la combinaison

#### Début de recherche (β ≈ 1)
- **AMAF dominant** : Exploite l'information de toutes les simulations
- **Convergence rapide** : Identifie rapidement les coups prometteurs
- **Exploration efficace** : Évite de perdre du temps sur de mauvais coups

#### Milieu de recherche (β ≈ 0.5)  
- **Équilibre optimal** : Combine vitesse AMAF et précision UCT
- **Raffinement progressif** : Améliore les estimations graduellement

#### Fin de recherche (β ≈ 0)
- **UCT précis** : Se fie aux statistiques directes et fiables
- **Convergence garantie** : Propriétés théoriques de UCT préservées

## Exemple de fonctionnement

### Simulation 1 : A → B → C → Victoire Blanc
```
Avant : AMAF[A] = 0/0, AMAF[B] = 0/0, AMAF[C] = 0/0
Après : AMAF[A] = 1/1, AMAF[B] = 1/1, AMAF[C] = 1/1
```

### Simulation 2 : D → A → E → Défaite Blanc
```
Avant : AMAF[A] = 1/1, AMAF[D] = 0/0, AMAF[E] = 0/0  
Après : AMAF[A] = 1/2, AMAF[D] = 0/1, AMAF[E] = 0/1
```

### Évaluation des coups
- **Coup A** : AMAF = 1/2 = 0.5 (moyennement bon)
- **Coup B** : AMAF = 1/1 = 1.0 (semble excellent)
- **Coup D** : AMAF = 0/1 = 0.0 (semble mauvais)

## Comparaison des performances

### Breakthrough 5×5 - Résultats typiques

| Algorithme | Simulations/s | Force relative | Convergence |
|------------|---------------|----------------|-------------|
| **Flat MC** | 5000 | Référence (50%) | Lente |
| **UCT** | 3000 | +15% | Modérée |
| **RAVE** | 2800 | +35% | **Rapide** |

### Gains de RAVE

#### Identification rapide
- **×10 plus rapide** pour distinguer bons/mauvais coups
- **Convergence précoce** vers les zones prometteuses

#### Précision améliorée  
- **Moins d'erreurs** dans l'évaluation des coups
- **Résistance au bruit** des simulations aléatoires

## Applications pratiques

### Jeux où RAVE excelle
- **Go** : Révolution des programmes (MoGo, Crazy Stone)
- **Hex** : Amélioration spectaculaire des IA
- **Breakthrough** : Convergence plus stable
- **Jeux connexion** : Partage d'information efficace

### Conditions favorables
- **Indépendance locale** : Coups ayant une valeur intrinsèque
- **Horizon long** : Parties avec de nombreux coups
- **Facteur de branchement élevé** : Beaucoup de choix possibles

## Limitations de RAVE

### Hypothèse AMAF violée
```python
# Exemple où AMAF trompe
# Dans certaines positions tactiques :
# Jouer A maintenant = Bon
# Jouer A plus tard = Mauvais (car l'opportunité a disparu)
```

### Biais potentiel
- **Surestimation** de coups généralement bons mais mauvais localement
- **Sous-estimation** de coups tactiques dépendant du timing
- **Pollution** par des statistiques non représentatives

## Optimisations et variantes

### RAVE avec seuil
```python
if t[3][code] > MIN_AMAF_SAMPLES:  # Seuil minimum
    # Utilise RAVE seulement si assez d'échantillons AMAF
    val = (1.0 - beta) * Q + beta * AMAF
else:
    # Retombe sur UCT pur
    val = Q + exploration_term
```

### GRAVE (Generalized RAVE)
Utilise les statistiques AMAF des nœuds ancêtres pour améliorer l'estimation.

### Killer RAVE
Privilégie les coups AMAF ayant eu de très bons résultats récents.

## Implémentation optimisée

### Gestion mémoire efficace
```python
class RAVENode:
    def __init__(self):
        self.uct_stats = defaultdict(lambda: [0, 0])      # [visits, wins]
        self.amaf_stats = defaultdict(lambda: [0, 0.0])   # [visits, wins]
        self.total_visits = 0
    
    def update_uct(self, move_idx, result):
        self.uct_stats[move_idx][0] += 1
        self.uct_stats[move_idx][1] += result
        self.total_visits += 1
    
    def update_amaf(self, move_codes, result):
        for code in set(move_codes):  # Évite doublons automatiquement
            self.amaf_stats[code][0] += 1
            self.amaf_stats[code][1] += result
```

### Calcul β optimisé
```python
def compute_beta(uct_visits, amaf_visits, bias=1e-5):
    if amaf_visits == 0:
        return 0.0
    denominator = uct_visits + amaf_visits + bias * uct_visits * amaf_visits
    return amaf_visits / denominator if denominator > 0 else 1.0
```

## Exemple d'utilisation complète

```python
# Initialisation
board = Board()
Table = {}

# Recherche RAVE
best_move = BestMoveRAVE(board, 1000)

# Affichage des statistiques
t = look(board)
moves = board.legalMoves()

for i, move in enumerate(moves):
    uct_avg = t[2][i] / t[1][i] if t[1][i] > 0 else 0
    code = move.code(board)
    amaf_avg = t[4][code] / t[3][code] if t[3][code] > 0 else 0
    beta = t[3][code] / (t[1][i] + t[3][code] + 1e-5 * t[1][i] * t[3][code])
    
    print(f"Coup {i}: UCT={uct_avg:.3f}, AMAF={amaf_avg:.3f}, β={beta:.3f}")
```

## Conclusion

RAVE représente une avancée majeure dans les algorithmes de recherche Monte Carlo. En combinant intelligemment les estimations UCT précises avec les approximations AMAF rapides, RAVE :

### Révolutionne l'efficacité
- **Convergence accélérée** vers les bonnes solutions
- **Utilisation optimale** des informations de simulation
- **Adaptation dynamique** entre rapidité et précision

### Ouvre de nouvelles possibilités
- **Base** pour algorithmes plus avancés (GRAVE, α-AMAF)
- **Parallélisation** efficace grâce au partage d'information
- **Applications** étendues au-delà des jeux traditionnels

Cette technique illustre parfaitement comment une hypothèse simple mais puissante peut transformer radicalement les performances d'un algorithme d'intelligence artificielle.