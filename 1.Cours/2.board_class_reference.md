# Classe Board - Jeu Breakthrough 5x5

## Vue d'ensemble

La classe `Board` implémente le plateau de jeu et la logique pour **Breakthrough**, un jeu de stratégie à deux joueurs sur un plateau 5x5. L'objectif est d'être le premier à atteindre la ligne de fond adverse avec un pion.

## Constantes globales

```python
Dx = 5      # Largeur du plateau
Dy = 5      # Hauteur du plateau
Empty = 0   # Case vide
White = 1   # Joueur blanc
Black = 2   # Joueur noir
```

## Règles de Breakthrough

- **Plateau** : Grille 5x5 avec 2 rangées de pions par joueur
- **Position initiale** : 
  - Blancs sur les lignes 0-1 (bas)
  - Noirs sur les lignes 3-4 (haut)
- **Objectif** : Premier joueur à atteindre la ligne opposée gagne
- **Mouvements** :
  - Avancer d'une case vers l'avant (verticalement)
  - Avancer en diagonale vers l'avant
  - Capturer en diagonale uniquement

## Structure de la classe

### Constructeur `__init__()`

```python
def __init__(self):
    self.h = 0                           # Hash pour table de transposition
    self.turn = White                    # Joueur actuel (commence par Blanc)
    self.board = np.zeros((Dx, Dy))      # Plateau 5x5
    
    # Placement des pions blancs (lignes 0-1)
    for i in range(0, 2):
        for j in range(0, Dy):
            self.board[i][j] = White
    
    # Placement des pions noirs (lignes 3-4)        
    for i in range(Dx - 2, Dx):
        for j in range(0, Dy):
            self.board[i][j] = Black
```

**Configuration initiale** :
```
Ligne 4: ♛ ♛ ♛ ♛ ♛  (Noirs)
Ligne 3: ♛ ♛ ♛ ♛ ♛  (Noirs)
Ligne 2:               (Vide)
Ligne 1: ♙ ♙ ♙ ♙ ♙  (Blancs)
Ligne 0: ♙ ♙ ♙ ♙ ♙  (Blancs)
```

### Méthode `legalMoves()`

Génère tous les coups légaux pour le joueur actuel.

```python
def legalMoves(self):
    moves = []
    for i in range(0, Dx):
        for j in range(0, Dy):
            if self.board[i][j] == self.turn:  # Trouve les pions du joueur
                for k in [-1, 0, 1]:           # Décalages en x
                    for l in [-1, 0, 1]:       # Décalages en y
                        m = Move(self.turn, i, j, i + k, j + l)
                        if m.valid(self):      # Vérifie la validité
                            moves.append(m)
    return moves
```

**Logique** :
1. Parcourt toutes les cases du plateau
2. Pour chaque pion du joueur actuel :
   - Teste les 9 directions possibles (3x3 autour du pion)
   - Utilise `Move.valid()` pour filtrer les coups légaux
3. Retourne la liste des coups valides

### Méthode `score()`

Évalue l'état terminal du jeu et retourne le score.

```python
def score(self):
    # Vérifie si un blanc a atteint la ligne de fond (victoire blanche)
    for i in range(0, Dy):
        if (self.board[Dx - 1][i] == White):
            return 1.0
        elif (self.board[0][i] == Black):  # Noir atteint ligne de fond
            return 0.0
    
    # Vérifie l'impasse (aucun coup possible)
    l = self.legalMoves()
    if len(l) == 0:
        if self.turn == Black:     # Noir ne peut pas jouer = Blanc gagne
            return 1.0
        else:                      # Blanc ne peut pas jouer = Noir gagne
            return 0.0
    
    return 0.5  # Partie en cours
```

**Valeurs de retour** :
- `1.0` : Victoire des Blancs
- `0.0` : Victoire des Noirs  
- `0.5` : Partie en cours

### Méthode `terminal()`

Détermine si la partie est terminée.

```python
def terminal(self):
    if self.score() == 0.5:  # Score 0.5 = partie continue
        return False
    return True              # Score 0.0 ou 1.0 = partie finie
```

### Méthode `play(move)`

Exécute un coup sur le plateau.

```python
def play(self, move):
    self.board[move.x1][move.y1] = Empty      # Vide case origine
    self.board[move.x2][move.y2] = move.color # Place pion destination
    
    # Alterne les joueurs
    if (self.turn == White):
        self.turn = Black
    else:
        self.turn = White
```

**Actions** :
1. Supprime le pion de sa position initiale
2. Place le pion à sa nouvelle position (capture automatique)
3. Change le joueur actuel

### Méthode `playout()`

Simule une partie aléatoire jusqu'à la fin.

```python
def playout(self):
    while (True):
        moves = self.legalMoves()
        if self.terminal():          # Partie terminée
            return self.score()      # Retourne le résultat
        n = random.randint(0, len(moves) - 1)  # Coup aléatoire
        self.play(moves[n])          # Joue le coup
```

**Utilisation** : Essentielle pour les algorithmes Monte Carlo qui nécessitent des simulations aléatoires complètes.

### Méthode `print()`

Affiche le plateau avec des symboles Unicode.

```python
def print(self):
    print("   1 2 3 4 5")
    for i in range(Dy):
        print("{} |".format(i + 1), end="")
        for j in range(Dx):
            if self.board[i][j] == Black:
                print("\u265F", end="")      # ♛ (pion noir)
            elif self.board[i][j] == White:
                print("\u2659", end="")      # ♙ (pion blanc)
            else:
                print(" ", end="")           # Case vide
            if j < Dx:
                print("|", end="")
        if i < Dy:
            print()
```

**Affichage** :
```
   1 2 3 4 5
1 |♛|♛|♛|♛|♛|
2 |♛|♛|♛|♛|♛|
3 | | | | | |
4 |♙|♙|♙|♙|♙|
5 |♙|♙|♙|♙|♙|
```

## Caractéristiques avancées

### Hachage (attribut `h`)
- Utilisé pour les tables de transposition dans UCT/MCTS
- Permet d'identifier rapidement les positions déjà évaluées
- Améliore l'efficacité des algorithmes de recherche

### Intégration avec les algorithmes IA

La classe Board est conçue pour s'intégrer avec :
- **Flat Monte Carlo** : Utilise `legalMoves()`, `play()`, `playout()`, `score()`
- **UCT/MCTS** : Exploite le hachage pour la mémorisation
- **Minimax** : Peut utiliser `score()` pour l'évaluation

## Exemple d'utilisation

```python
# Création d'une nouvelle partie
board = Board()
board.print()

# Génération des coups possibles
moves = board.legalMoves()
print(f"Coups possibles : {len(moves)}")

# Jouer un coup aléatoire
import random
move = random.choice(moves)
board.play(move)
board.print()

# Simulation complète
result = board.playout()
print(f"Résultat de simulation : {result}")
```

## Points d'optimisation

### Performance
- `copy.deepcopy()` nécessaire pour Flat Monte Carlo peut être coûteux
- Possibilité d'optimiser avec des copies plus légères
- Génération des coups légaux pourrait être mise en cache

### Extensibilité
- Facilement adaptable à d'autres tailles (changement de `Dx`, `Dy`)
- Structure modulaire permettant l'ajout de variantes
- Interface claire pour l'intégration avec différents algorithmes

## Conclusion

La classe Board fournit une implémentation complète et robuste du jeu Breakthrough, optimisée pour les algorithmes de recherche Monte Carlo. Sa conception modulaire la rend facilement extensible et réutilisable pour d'autres projets d'IA de jeux.