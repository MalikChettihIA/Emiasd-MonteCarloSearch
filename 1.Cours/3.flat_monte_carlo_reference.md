# Algorithme Flat Monte Carlo

## Vue d'ensemble

L'algorithme **Flat Monte Carlo** est une méthode de recherche par simulation pour les jeux à deux joueurs. Contrairement aux algorithmes comme UCT (Upper Confidence Trees), il ne construit pas d'arbre de recherche mais effectue des simulations uniformes pour évaluer les coups possibles.

## Principe de fonctionnement

Le Flat Monte Carlo évalue chaque coup possible en effectuant un nombre fixe de simulations (playouts) aléatoires depuis la position résultante de ce coup, puis sélectionne le coup avec le meilleur score moyen.

## Analyse du code

### Fonction `flat(board, n)`

```python
def flat(board, n):
    moves = board.legalMoves()
    bestScore = 0
    bestMove = 0
    
    for m in range(len(moves)):
        sum = 0
        for i in range(n // len(moves)):
            b = copy.deepcopy(board)
            b.play(moves[m])
            r = b.playout()
            if board.turn == Black:
                r = 1 - r
            sum = sum + r
        
        if sum > bestScore:
            bestScore = sum
            bestMove = m
    
    return moves[bestMove]
```

### Étapes détaillées

1. **Initialisation**
   - `moves = board.legalMoves()` : Obtient tous les coups légaux
   - `bestScore = 0` : Score du meilleur coup trouvé
   - `bestMove = 0` : Index du meilleur coup

2. **Évaluation de chaque coup**
   - Pour chaque coup `m` dans la liste des coups possibles :
     - Effectue `n // len(moves)` simulations (répartition équitable du budget)
     - Pour chaque simulation :
       - Copie profonde du plateau : `b = copy.deepcopy(board)`
       - Joue le coup testé : `b.play(moves[m])`
       - Lance une simulation aléatoire : `r = b.playout()`

3. **Normalisation du score**
   ```python
   if board.turn == Black:
       r = 1 - r
   ```
   - Ajuste le résultat selon le joueur actuel
   - Si c'est au tour des Noirs, inverse le score (1-r)
   - Assure que le score reflète toujours la perspective du joueur courant

4. **Accumulation et sélection**
   - `sum = sum + r` : Accumule les scores des simulations
   - Met à jour le meilleur coup si le score cumulé est supérieur

5. **Retour**
   - Retourne le coup avec le meilleur score moyen

## Caractéristiques

### Avantages
- **Simplicité** : Implémentation directe et facile à comprendre
- **Pas de paramètres complexes** : Seul le nombre de simulations à régler
- **Robustesse** : Bon comportement sur des jeux avec des positions complexes
- **Parallélisation facile** : Les simulations sont indépendantes

### Inconvénients
- **Efficacité limitée** : Ne tire pas parti de l'information des simulations précédentes
- **Pas d'apprentissage** : Ne construit pas de connaissance réutilisable
- **Allocation uniforme** : Donne le même temps à tous les coups, même les mauvais

## Comparaison avec d'autres méthodes

### Vs UCT (Upper Confidence Trees)
- **UCT** : Construit un arbre, concentre les simulations sur les branches prometteuses
- **Flat MC** : Traite tous les coups équitablement, plus simple mais moins efficace

### Vs Minimax
- **Minimax** : Recherche exhaustive avec élagage alpha-bêta
- **Flat MC** : Échantillonnage statistique, meilleur pour les jeux avec de grands facteurs de branchement

## Applications typiques

- **Jeux de Go** : Historiquement utilisé avant l'avènement d'UCT
- **Jeux complexes** : Positions où l'évaluation heuristique est difficile
- **Prototypage rapide** : Base simple pour développer des IA de jeu
- **Benchmark** : Point de comparaison pour des algorithmes plus sophistiqués

## Paramètres d'optimisation

### Nombre de simulations (n)
- Plus `n` est grand, plus l'estimation est précise
- Compromis entre précision et temps de calcul
- Typiquement entre 1000 et 100000 simulations

### Politique de playout
- `b.playout()` : Joue aléatoirement jusqu'à la fin de partie
- Peut être amélioré avec des heuristiques légères
- Impact majeur sur la qualité des estimations

## Extensions possibles

1. **Flat AMAF** : Intègre les statistiques All-Moves-As-First
2. **Pondération progressive** : Donne plus de poids aux simulations récentes
3. **Playout guidé** : Utilise des heuristiques dans les simulations
4. **Parallélisation** : Distribution des simulations sur plusieurs threads

## Code d'exemple d'utilisation

```python
# Utilisation basique
best_move = flat(current_board, 10000)
current_board.play(best_move)

# Avec ajustement du nombre de simulations selon le temps
import time
start_time = time.time()
simulations = 1000
while time.time() - start_time < 5.0:  # 5 secondes max
    simulations += 1000
    if simulations > 50000:  # Limite max
        break

best_move = flat(current_board, simulations)
```

## Notes d'implémentation

- **Gestion mémoire** : `copy.deepcopy()` peut être coûteux, optimisations possibles
- **Générateur aléatoire** : Qualité importante pour les playouts
- **Gestion des fins de partie** : `b.playout()` doit gérer tous les cas terminaux
- **Normalisation** : Crucial que les scores soient dans [0,1] et cohérents

## Conclusion

Le Flat Monte Carlo reste un algorithme fondamental dans l'arsenal des méthodes de recherche par Monte Carlo. Sa simplicité en fait un excellent point de départ pour comprendre les principes de base avant d'aborder des méthodes plus sophistiquées comme MCTS/UCT.